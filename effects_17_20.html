<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Weapon Systems - Exotic & Fire</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { width: 100vw; height: 100vh; }
        #ui {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
            width: 90%;
            overflow-x: auto;
            justify-content: center;
        }
        .weapon-card {
            pointer-events: auto;
            border: 1px solid #333;
            background: #1a1a1a;
            color: #888;
            padding: 8px;
            min-width: 110px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            flex-shrink: 0;
        }
        .weapon-card:hover { background: #2a2a2a; color: #fff; }
        .weapon-card.active {
            border-color: #ffaa00;
            background: #3a2a00;
            color: #fff;
            box-shadow: 0 0 15px rgba(255, 170, 0, 0.3);
        }
        .icon { font-size: 20px; display: block; margin-bottom: 5px; }
        .name { font-size: 11px; font-weight: bold; }
        .stats { font-size: 9px; margin-top: 4px; opacity: 0.7; }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0.7;
        }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: rgba(255, 255, 255, 0.8); }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="canvas-container"></div>
    <div id="ui"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // --- CONFIGURATION ---
        const WEAPONS = [
            { id: "w_17", name: "Napalm Thrower", type: "Fire", icon: "ðŸ”¥", base: { dmg: 4, cd: 0.02, range: 40, speed: 25, cone: 0.2 }, color: 0xff5500, desc: "Stream of fire." },
            { id: "w_18", name: "Railgun Sniper", type: "Rail", icon: "âš¡", base: { dmg: 150, cd: 1.5, range: 200, width: 0.1, pierce: 99 }, color: 0x00ffff, desc: "Infinite pierce." },
            { id: "w_19", name: "Glitch Emitter", type: "Glitch", icon: "ðŸ‘¾", base: { dmg: 10, cd: 0.1, range: 60, speed: 40 }, color: 0xff00ff, desc: "Randomizes reality." },
            { id: "w_20", name: "Bit-Coin Blaster", type: "Coin", icon: "ðŸª™", base: { dmg: 5, cd: 0.15, range: 50, speed: 30 }, color: 0xffd700, desc: "Shoots money." },
        ];

        let currentWeaponIndex = 0, lastFireTime = 0, isMouseDown = false;
        
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        // --- FX ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.3, 0.5);
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);
        composer.addPass(new OutputPass());

        scene.add(new THREE.AmbientLight(0x404040));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        const gridHelper = new THREE.GridHelper(100, 50, 0x222222, 0x111111);
        scene.add(gridHelper);
        const planeGeo = new THREE.PlaneGeometry(200, 200);
        const planeMat = new THREE.MeshBasicMaterial({ visible: false });
        const floorMesh = new THREE.Mesh(planeGeo, planeMat);
        floorMesh.rotation.x = -Math.PI / 2;
        scene.add(floorMesh);

        const walls = [];
        const wallMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.2 });
        [[30,0], [-30,0], [0,30], [0,-30]].forEach(pos => {
            const w = new THREE.Mesh(new THREE.BoxGeometry(pos[0]?2:60, 5, pos[1]?2:60), wallMat);
            w.position.set(pos[0], 2.5, pos[1]);
            scene.add(w);
            walls.push(w);
        });

        const targets = [];
        const targetGeo = new THREE.BoxGeometry(2, 3, 2);
        const targetMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.2 });
        for(let i=0; i<10; i++) {
            const t = new THREE.Mesh(targetGeo, targetMat.clone());
            t.position.set((Math.random()-0.5)*40, 1.5, (Math.random()-0.5)*40);
            t.userData = { id: i, hp: 100 };
            scene.add(t);
            targets.push(t);
        }

        const gunMesh = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 2), new THREE.MeshStandardMaterial({ color: 0x444444 }));
        gunMesh.position.set(0, 1.5, 0);
        scene.add(gunMesh);
        const muzzleOffset = new THREE.Vector3(0, 0, -1.2); 

        // --- SYSTEMS ---

        // 1. FIRE SYSTEM (Napalm)
        class FireSystem {
            constructor(scene) {
                this.maxCount = 1000;
                const geo = new THREE.PlaneGeometry(0.8, 0.8);
                const mat = new THREE.MeshBasicMaterial({
                    color: 0xff5500, transparent: true, opacity: 0.0, blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.DoubleSide
                });
                this.mesh = new THREE.InstancedMesh(geo, mat, this.maxCount);
                this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                this.mesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(this.maxCount * 3), 3);
                scene.add(this.mesh);
                
                this.particles = Array(this.maxCount).fill().map(() => ({ active: false, life: 0, vel: new THREE.Vector3() }));
                this.dummy = new THREE.Object3D();
                
                for(let i=0; i<this.maxCount; i++) {
                    this.dummy.scale.set(0,0,0);
                    this.dummy.updateMatrix();
                    this.mesh.setMatrixAt(i, this.dummy.matrix);
                }
            }

            fire(origin, dir, w) {
                // Emit burst
                const count = 2;
                for(let k=0; k<count; k++) {
                    const idx = this.particles.findIndex(p => !p.active);
                    if(idx === -1) return;
                    const p = this.particles[idx];
                    p.active = true; p.life = 1.0 + Math.random() * 0.5;
                    
                    // Spread
                    const d = dir.clone();
                    d.x += (Math.random()-0.5) * w.base.cone;
                    d.y += (Math.random()-0.5) * w.base.cone;
                    d.z += (Math.random()-0.5) * w.base.cone;
                    d.normalize();
                    
                    p.vel.copy(d).multiplyScalar(w.base.speed * (0.8 + Math.random()*0.4));
                    
                    this.dummy.position.copy(origin);
                    this.dummy.scale.set(0.5, 0.5, 0.5);
                    this.dummy.updateMatrix();
                    this.mesh.setMatrixAt(idx, this.dummy.matrix);
                    
                    // Randomize color slightly (Orange to Yellow)
                    const col = new THREE.Color(w.color);
                    col.r += Math.random() * 0.2;
                    col.g += Math.random() * 0.5;
                    this.mesh.setColorAt(idx, col);
                }
                this.mesh.instanceMatrix.needsUpdate = true;
                this.mesh.instanceColor.needsUpdate = true;
            }

            update(dt) {
                let dirty = false;
                const ray = new THREE.Raycaster();
                
                for(let i=0; i<this.maxCount; i++) {
                    const p = this.particles[i];
                    if(p.active) {
                        p.life -= dt;
                        
                        // Physics: Slow down and float up
                        p.vel.multiplyScalar(0.95); 
                        p.vel.y += 2.0 * dt; 

                        this.mesh.getMatrixAt(i, this.dummy.matrix);
                        const pos = new THREE.Vector3().setFromMatrixPosition(this.dummy.matrix);
                        const nextPos = pos.clone().addScaledVector(p.vel, dt);
                        
                        // Floor collision (leave puddle)
                        if(nextPos.y < 0.1) {
                            p.vel.y = 0;
                            nextPos.y = 0.1;
                            p.vel.multiplyScalar(0.5); // Friction
                        }

                        this.dummy.position.copy(nextPos);
                        this.dummy.lookAt(camera.position); // Billboard
                        
                        // Scale based on life (grow then shrink)
                        const scale = (p.life > 1.0) ? (1.5 - p.life) + 0.5 : p.life * 1.5;
                        this.dummy.scale.set(scale, scale, scale);
                        
                        this.dummy.updateMatrix();
                        this.mesh.setMatrixAt(i, this.dummy.matrix);
                        dirty = true;

                        if(p.life <= 0) {
                            p.active = false;
                            this.dummy.scale.set(0,0,0);
                            this.dummy.updateMatrix();
                            this.mesh.setMatrixAt(i, this.dummy.matrix);
                        }
                    }
                }
                if(dirty) this.mesh.instanceMatrix.needsUpdate = true;
            }
        }

        // 2. RAILGUN SYSTEM (Instant Pierce)
        class RailSystem {
            constructor(scene) {
                this.scene = scene;
                this.beams = []; // Store { mesh, life }
            }

            fire(origin, dir, w, targetEnts) {
                // 1. Visuals: Create a Cylinder
                const geo = new THREE.CylinderGeometry(w.base.width, w.base.width, 1, 8);
                geo.translate(0, 0.5, 0);
                geo.rotateX(Math.PI / 2);
                
                const mat = new THREE.MeshBasicMaterial({ color: w.color, transparent: true, opacity: 1.0, blending: THREE.AdditiveBlending });
                const mesh = new THREE.Mesh(geo, mat);
                this.scene.add(mesh);

                // 2. Logic: Raycast infinite
                // We need to find the furthest hit to stretch the beam to, 
                // BUT piercing means we hit everything along the way.
                const ray = new THREE.Raycaster(origin, dir);
                const hits = ray.intersectObjects([...targetEnts, ...walls, floorMesh]);
                
                // Determine beam end point (default max range)
                let endPoint = origin.clone().add(dir.clone().multiplyScalar(w.base.range));
                let wallHit = hits.find(h => h.object === floorMesh || walls.includes(h.object));
                
                if(wallHit) endPoint.copy(wallHit.point);

                // Position Visual
                const length = origin.distanceTo(endPoint);
                mesh.position.copy(origin);
                mesh.lookAt(endPoint);
                mesh.scale.set(1, 1, length);

                // Apply Damage/Effects to pierced targets
                const pierced = hits.filter(h => targetEnts.includes(h.object) && h.distance < length);
                pierced.forEach(hit => {
                    // Impact effect
                    const t = hit.object;
                    t.material.emissive.setHex(w.color);
                    setTimeout(() => t.material.emissive.setHex(0x000000), 100);
                    
                    // Simple Spark
                    const s = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.2), new THREE.MeshBasicMaterial({color: w.color}));
                    s.position.copy(hit.point);
                    scene.add(s);
                    setTimeout(()=>scene.remove(s), 200);
                });

                // Store for fading
                this.beams.push({ mesh, life: 0.5, maxLife: 0.5 });
                
                // Camera shake
                camera.position.y -= 0.2;
            }

            update(dt) {
                for(let i=this.beams.length-1; i>=0; i--) {
                    const b = this.beams[i];
                    b.life -= dt;
                    
                    // Fade out width and opacity
                    const progress = b.life / b.maxLife;
                    b.mesh.material.opacity = progress;
                    b.mesh.scale.x = progress * 2.0; // Start wide, shrink
                    b.mesh.scale.y = progress * 2.0;

                    if(b.life <= 0) {
                        this.scene.remove(b.mesh);
                        b.mesh.geometry.dispose();
                        b.mesh.material.dispose();
                        this.beams.splice(i, 1);
                    }
                }
            }
        }

        // 3. GLITCH SYSTEM (Chaotic Projectiles)
        class GlitchSystem {
            constructor(scene) {
                this.bullets = Array(50).fill().map(() => ({ active: false, vel: new THREE.Vector3(), life: 0 }));
                this.dummy = new THREE.Object3D();
                
                // Cube geometry
                const geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
                
                this.mesh = new THREE.InstancedMesh(geo, mat, 50);
                this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                this.mesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(50 * 3), 3);
                scene.add(this.mesh);
            }

            fire(origin, dir, w) {
                const idx = this.bullets.findIndex(b => !b.active);
                if(idx === -1) return;
                
                const b = this.bullets[idx];
                b.active = true; b.life = 2.0;
                b.vel.copy(dir).multiplyScalar(w.base.speed);
                b.baseColor = new THREE.Color(w.color);

                this.dummy.position.copy(origin);
                this.dummy.updateMatrix();
                this.mesh.setMatrixAt(idx, this.dummy.matrix);
                this.mesh.instanceMatrix.needsUpdate = true;
            }

            update(dt) {
                let dirty = false;
                for(let i=0; i<50; i++) {
                    const b = this.bullets[i];
                    if(!b.active) continue;

                    // Glitch Logic: Random Scale and Color every frame
                    this.mesh.getMatrixAt(i, this.dummy.matrix);
                    const pos = new THREE.Vector3().setFromMatrixPosition(this.dummy.matrix);
                    pos.addScaledVector(b.vel, dt);

                    // Random Jitter Position
                    const jitter = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).multiplyScalar(0.2);
                    const drawPos = pos.clone().add(jitter);

                    this.dummy.position.copy(drawPos);
                    this.dummy.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
                    this.dummy.scale.set(Math.random()*2, Math.random()*2, Math.random()*2);
                    this.dummy.updateMatrix();
                    this.mesh.setMatrixAt(i, this.dummy.matrix);

                    // Random Color (Neon)
                    const rCol = new THREE.Color().setHSL(Math.random(), 1.0, 0.5);
                    this.mesh.setColorAt(i, rCol);

                    // Collision
                    const ray = new THREE.Raycaster(pos, b.vel.clone().normalize(), 0, b.vel.length()*dt);
                    const hits = ray.intersectObjects(targets);
                    if(hits.length > 0) {
                        // Glitch Hit Effect: Randomly scale target
                        const t = hits[0].object;
                        t.scale.set(Math.random()*2 + 0.5, Math.random()*2 + 0.5, Math.random()*2 + 0.5);
                        setTimeout(() => t.scale.set(1,1,1), 200);
                        b.active = false;
                        this.dummy.scale.set(0,0,0);
                        this.dummy.updateMatrix();
                        this.mesh.setMatrixAt(i, this.dummy.matrix);
                    }

                    b.life -= dt;
                    if(b.life <= 0) {
                        b.active = false;
                        this.dummy.scale.set(0,0,0);
                        this.dummy.updateMatrix();
                        this.mesh.setMatrixAt(i, this.dummy.matrix);
                    }
                    dirty = true;
                }
                if(dirty) {
                    this.mesh.instanceMatrix.needsUpdate = true;
                    this.mesh.instanceColor.needsUpdate = true;
                }
            }
        }

        // 4. COIN SYSTEM (Physics Projectiles)
        class CoinSystem {
            constructor(scene) {
                this.coins = Array(100).fill().map(() => ({ active: false, vel: new THREE.Vector3(), angVel: new THREE.Vector3(), life: 0 }));
                this.dummy = new THREE.Object3D();
                
                // Coin shape
                const geo = new THREE.CylinderGeometry(0.3, 0.3, 0.05, 16);
                geo.rotateX(Math.PI/2); // Face forward
                const mat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 1.0, roughness: 0.2 });
                
                this.mesh = new THREE.InstancedMesh(geo, mat, 100);
                this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                scene.add(this.mesh);
            }

            fire(origin, dir, w) {
                const idx = this.coins.findIndex(c => !c.active);
                if(idx === -1) return;
                
                const c = this.coins[idx];
                c.active = true; c.life = 3.0;
                c.vel.copy(dir).multiplyScalar(w.base.speed);
                // Add slight arc
                c.vel.y += 5.0; 
                c.angVel.set(Math.random()*10, Math.random()*10, Math.random()*10);

                this.dummy.position.copy(origin);
                this.dummy.updateMatrix();
                this.mesh.setMatrixAt(idx, this.dummy.matrix);
                this.mesh.instanceMatrix.needsUpdate = true;
            }

            update(dt) {
                let dirty = false;
                for(let i=0; i<100; i++) {
                    const c = this.coins[i];
                    if(!c.active) continue;

                    c.life -= dt;
                    c.vel.y -= 20.0 * dt; // Gravity

                    this.mesh.getMatrixAt(i, this.dummy.matrix);
                    const pos = new THREE.Vector3().setFromMatrixPosition(this.dummy.matrix);
                    const nextPos = pos.clone().addScaledVector(c.vel, dt);

                    // Floor Bounce
                    if(nextPos.y < 0.2) {
                        nextPos.y = 0.2;
                        c.vel.y *= -0.6; // Bounce
                        c.vel.x *= 0.8; // Friction
                        c.vel.z *= 0.8;
                    }

                    // Hit Logic
                    const ray = new THREE.Raycaster(pos, c.vel.clone().normalize(), 0, c.vel.length()*dt);
                    const hits = ray.intersectObjects(targets);
                    if(hits.length > 0) {
                        // Bounce off enemy
                        c.vel.multiplyScalar(-0.5);
                        c.vel.y += 5;
                        // Spawn Float Text (Simulated by a box for now)
                        const t = hits[0].object;
                        t.material.emissive.setHex(0xffd700);
                        setTimeout(() => t.material.emissive.setHex(0x000000), 50);
                    }

                    // Rotate Visual
                    const rot = new THREE.Quaternion().setFromEuler(new THREE.Euler(c.angVel.x*dt, c.angVel.y*dt, c.angVel.z*dt));
                    this.dummy.quaternion.multiply(rot); // Simplified rotation accumulation need extraction, assume simple spin for demo
                    this.dummy.rotation.x += c.angVel.x * dt; // Simple spin
                    
                    this.dummy.position.copy(nextPos);
                    this.dummy.scale.set(1,1,1);
                    this.dummy.updateMatrix();
                    this.mesh.setMatrixAt(i, this.dummy.matrix);
                    
                    if(c.life <= 0) {
                        c.active = false;
                        this.dummy.scale.set(0,0,0);
                        this.dummy.updateMatrix();
                        this.mesh.setMatrixAt(i, this.dummy.matrix);
                    }
                    dirty = true;
                }
                if(dirty) this.mesh.instanceMatrix.needsUpdate = true;
            }
        }

        // --- INSTANTIATION ---
        const fireSys = new FireSystem(scene);
        const railSys = new RailSystem(scene);
        const glitchSys = new GlitchSystem(scene);
        const coinSys = new CoinSystem(scene);

        const uiContainer = document.getElementById('ui');
        WEAPONS.forEach((w, index) => {
            const btn = document.createElement('div');
            btn.className = `weapon-card ${index === 0 ? 'active' : ''}`;
            btn.innerHTML = `<span class="icon">${w.icon}</span><span class="name">${w.name}</span><div class="stats">${w.desc}</div>`;
            btn.onclick = () => {
                currentWeaponIndex = index;
                document.querySelectorAll('.weapon-card').forEach(c => c.classList.remove('active'));
                btn.classList.add('active');
            };
            uiContainer.appendChild(btn);
        });

        const mouse = new THREE.Vector2();
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const raycaster = new THREE.Raycaster();
        
        window.addEventListener('mousemove', e => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });
        window.addEventListener('mousedown', () => isMouseDown = true);
        window.addEventListener('mouseup', () => isMouseDown = false);
        window.addEventListener('keydown', e => {
            const k = parseInt(e.key);
            if(k >= 1 && k <= WEAPONS.length) {
                currentWeaponIndex = k-1;
                document.querySelectorAll('.weapon-card').forEach((c,i) => c.classList.toggle('active', i===k-1));
            }
        });
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
        });

        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            targets.forEach(t => { t.rotation.y += dt; t.position.y = 1.5 + Math.sin(time + t.userData.id)*0.5; });

            raycaster.setFromCamera(mouse, camera);
            const intersect = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersect);
            if(intersect) {
                const lookPos = intersect.clone(); lookPos.y = 1.5;
                gunMesh.lookAt(lookPos);
            }

            const w = WEAPONS[currentWeaponIndex];
            const muzzlePos = new THREE.Vector3();
            gunMesh.localToWorld(muzzlePos.copy(muzzleOffset));
            const dir = new THREE.Vector3().subVectors(intersect || new THREE.Vector3(0,0,10), muzzlePos).normalize();

            const canFire = (w.type === "Fire") ? isMouseDown : (isMouseDown && time - lastFireTime >= w.base.cd);

            if(canFire) {
                if(w.type !== "Fire") lastFireTime = time;
                
                switch(w.type) {
                    case "Fire": fireSys.fire(muzzlePos, dir, w); break;
                    case "Rail": railSys.fire(muzzlePos, dir, w, targets); break;
                    case "Glitch": glitchSys.fire(muzzlePos, dir, w); break;
                    case "Coin": coinSys.fire(muzzlePos, dir, w); break;
                }

                if(w.type !== "Fire" || Math.random() > 0.8) {
                    gunMesh.position.z += 0.2;
                    const light = new THREE.PointLight(w.color, 5, 10);
                    light.position.copy(muzzlePos);
                    scene.add(light);
                    setTimeout(() => scene.remove(light), 50);
                }
            }
            
            gunMesh.position.z = THREE.MathUtils.lerp(gunMesh.position.z, 0, dt*10);

            fireSys.update(dt);
            railSys.update(dt);
            glitchSys.update(dt);
            coinSys.update(dt);

            composer.render();
        }
        animate();
    </script>
</body>
</html>